	 ______   ___    ___
	/\  _  \ /\_ \  /\_ \
	\ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
	 \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
	  \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
	   \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
	    \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
					   /\____/
					   \_/__/     Version 2.0


	       A game programming library for djgpp

		   By Shawn Hargreaves, 1994/96



#include <std_disclaimer.h>

   "I do not accept responsibility for any effects, adverse or otherwise, 
    that this code may have on you, your computer, your sanity, your dog, 
    and anything else that you can think of. Use it at your own risk."



=======================================
============ Using Allegro ============
=======================================

See readme.txt for a general introduction and copyright information.

All the Allegro functions and data structures are defined in allegro.h. You 
should include this in your programs, and link with liballeg.a. The easiest 
way to do this is probably just to copy allegro.h and liballeg.a into your 
djgpp include and lib directories respectively and then #include <allegro.h> 
and put '-lalleg' on your linker command line. Alternatively you could add 
your Allegro directory to the C_INCLUDE_PATH and LIBRARY_PATH in djgpp.env, 
or just specify full paths for everything, eg. #include </allegro/allegro.h> 
and 'gcc foobar.c -o foobar.exe /allegro/liballeg.a'.

extern char allegro_id[];
   Contains a date and version number, in case you want to display these 
   somewhere.

extern char allegro_error[];
   Used by set_gfx_mode() and install_sound() to report error messages. If 
   they fail and you want to tell the user why, this is the place to look.

int allegro_init();
   Initialises the Allegro library. It doesn't actually do very much except 
   setting up some global variables, locking some memory, and installing 
   allegro_exit() as an atexit() routine, but you _must_ call it before 
   doing anything else.

void allegro_exit();
   Closes down the Allegro system. This includes returning the system to 
   text mode and removing whatever mouse, keyboard, and timer routines have 
   been installed. You don't actually need to bother calling this manually, 
   because allegro_init() installs it as an atexit() routine.



========================================
============ Mouse routines ============
========================================

int install_mouse();
   Installs the Allegro mouse handler. You must do this before using any 
   other mouse functions. Returns zero for success, and non-zero if the DOS
   mouse driver (usually mouse.com or mouse.exe) is not loaded.

void remove_mouse();
   Removes the mouse handler. You don't normally need to call this, because 
   allegro_exit() will do it for you.

extern volatile int mouse_x;
extern volatile int mouse_y;
extern volatile int mouse_b;
   Global variables containing the current mouse position and button state.

void show_mouse(BITMAP *bmp);
   Tells Allegro to display a mouse pointer on the screen. This will only 
   work if the timer module has been installed. The mouse pointer will be 
   drawn onto the bitmap bmp, which should normally be 'screen' (see later 
   for information about bitmaps). To turn off the mouse pointer, which you 
   must do before you draw anything onto the screen, call show_mouse(NULL). 
   If you forget to turn off the mouse pointer when you draw something, the 
   SVGA bank switching code will get confused and will leave mouse droppings 
   all over the screen.

void set_mouse_sprite(BITMAP *sprite);
   You don't like my mouse pointer? No problem. Use this function to supply 
   an alternative of your own. If you change the pointer and then want to 
   get my lovely arrow back again, call set_mouse_sprite(NULL).

void position_mouse(int x, int y);
   Moves the mouse to the specified screen position. This is safe to call 
   even when a mouse pointer is being displayed.



========================================
============ Timer routines ============
========================================

The standard PC clock only ticks 18.2 times a second, which is not much good 
for high speed games. Allegro can replace the system timer routine with a 
custom one, which reprograms the clock for higher tick rates while still 
calling the BIOS handler at the old speed. You can setup several 'virtual 
timers' of your own, all going at different speeds, and Allegro will 
constantly reprogram the clock to make sure they are all called at the 
correct times.

int install_timer();
   Installs the Allegro timer interrupt handler. You must do this before 
   installing any user timer routines, and also before trying to display a 
   mouse pointer, play MIDI music, or use any of the GUI routines.

void remove_timer();
   Removes the Allegro timer handler and passes control of the clock back to 
   the BIOS. You don't normally need to call this, because allegro_exit() 
   will do it for you.

int install_int(void (*proc)(), int speed);
   Installs a user timer handler, with the speed given in milliseconds. This 
   is the same thing as calling install_int_ex(proc, MSEC_TO_TIMER(speed)).

int install_int_ex(void (*proc)(), int speed);
   Installs a function into the list of user timer handlers, or if it is 
   already installed, adjusts its speed. The speed is given in hardware 
   clock ticks, of which there are 1193181 a second. You can convert from 
   other time formats to hardware clock ticks with the macros SECS_TO_TIMER 
   (to specify the number of seconds between each call to your routine), 
   MSEC_TO_TIMER (to give the number of milliseconds between each call to 
   your routine), BPS_TO_TIMER (to specify how many ticks each second), and 
   BPM_TO_TIMER (to specify the number of ticks per minute). Returns a 
   negative number if there was no room to add a new timer. There can only 
   be eight user timers in use at a time, and some other parts of Allegro 
   (the GUI code, the mouse pointer display routines, rest(), and the MIDI 
   player) need to install ones of their own, so you should avoid using more 
   than three or four at a time.

   Your function will be called by the Allegro interrupt handler and not 
   directly by the processor, so it can be a normal C function and does not 
   need any special wrapper. You should be aware, however, that it will be 
   called in an interrupt context, which imposes several restrictions on 
   what you can do in it. It should not use large amounts of stack, it must 
   not make any calls to DOS or use C library functions which may in turn 
   call DOS routines, and it must execute quickly (don't try to do lots of 
   game logic in a timer handler: just set a flag and check this in your 
   main game loop).

   In a protected mode environment like djgpp, memory is be virtualised and 
   can be swapped to disk. If a disk swap occurs inside an interrupt 
   handler, the system will hang, so you need to make sure you lock all the 
   memory (both code and data) which is used inside timer routines. Allegro 
   will lock all the memory it touches, but you are responsible for locking 
   your handler functions. The macros LOCK_VARIABLE(x) and LOCK_FUNCTION(x) 
   can be used to simplify this task (look at the Allegro code for an 
   example of how they are used), or you can just tell djgpp to lock all the 
   memory your program uses, which will disable virtual memory entirely, 
   with the lines:

   #include <crt0.h>
   int _crt0_startup_flags = _CRT0_FLAG_NONMOVE_SBRK | _CRT0_FLAG_LOCK_MEMORY;

void remove_int(void (*proc)());
   Removes a function from the list of user interrupt routines. At program 
   termination, allegro_exit() does this automatically.

void rest(long time);
   Once Allegro has taken over the timer, delay() will no longer work, so 
   you should use this function instead. The time is given in milliseconds.



===========================================
============ Keyboard routines ============
===========================================

If you want to detect multiple keypresses at the same time, the standard DOS 
keyboard routines are useless. Allegro can install a replacement keyboard 
handler, which provides both buffered input and a set of flags storing the 
state of each key. Note that it is not possible to detect all possible 
combinations of key presses, due to the design of the PC keyboard. Up to two 
or three keys at a time will work fine, but if you press more than that the 
extras are likely to be ignored.

int install_keyboard();
   Installs the Allegro keyboard interrupt handler. You must call this 
   before using any of the keyboard input routines. Once you have set up the 
   Allegro handler, you can no longer use DOS calls or C library functions 
   to access the keyboard.

void remove_keyboard();
   Removes the keyboard handler, returning control to the BIOS. You don't 
   normally need to call this, because allegro_exit() will do it for you.

extern volatile char key[128];
   Array of flags indicating the state of each key, by scancode (TRUE = 
   pressed, FALSE = not pressed). The scancodes are defined in allegro.h as 
   a series of KEY_* constants. For example, you could write:

   if (key[KEY_SPACE])
      printf("Space is pressed\n");

int readkey();
   Returns the next character from the keyboard buffer. If the buffer is 
   empty, it waits until a key is pressed. The low byte of the return value 
   contains the ascii code of the key, and the high byte the scan code. The 
   scancode -> ascii conversion ignores the state of the ctrl and alt keys, 
   but is aware of the shift state.

int keypressed();
   Returns TRUE if there are keypresses waiting in the keyboard buffer.

void clear_keybuf();
   Empties the keyboard buffer.

The Allegro keyboard handler provides an 'emergency exit' sequence which you 
can use to kill off your program if it gets stuck in an endless loop. If you 
are running under DOS this is the three finger salute, ctrl+alt+del. Most 
multitasking OS's will trap this combination before it reaches Allegro, in 
which case you can use the alternative ctrl+alt+end. If you want to disable 
this feature in a release version of your program, you can set the global 
variable three_finger_flag to FALSE.



===========================================
============ Joystick routines ============
===========================================

int initialise_joystick();
   Initialises the joystick, and calibrates the centre position value. You 
   must call this before using any other joystick functions, and should make 
   sure the user has centered the joystick when you do. Returns non-zero if 
   there is no joystick present (in which case you can still call the other 
   joystick routines, but they will all return zero positions).

void poll_joystick();
   Updates the global joystick position values.

extern int joy_x, joy_y;
   Analogue axis positions, from -128 to 128. You must fully calibrate the 
   joystick before using these variables: see below. Call poll_joystick() to 
   update them.

extern int joy_left, joy_right, joy_up, joy_down;
   To simulate a digital joystick, these variables will contain non-zero if 
   the joystick is moved in the relevant direction. You don't need to fully 
   calibrate the joystick in order to use these: just initialise_joystick() 
   is enough (this is how the demo game accesses the joystick). Call 
   poll_joystick() to update them.

extern int joy_b1, joy_b2;
   Joystick button states. Call poll_joystick() to update them. Note that 
   these values will bounce between the two states a few times when the 
   button is pressed or released, so in some situations you may need to add 
   a small delay after the buttons change state (see test.c for an example).

int calibrate_joystick_tl();
int calibrate_joystick_br();
   Getting analogue input from the PC joystick is not a pleasant task. It 
   depends on a timing loop, the results of which vary depending on the type 
   of joystick, the speed of your computer, the temperature of the room, and 
   the phases of the moon. If you want to get meaningful values from the 
   joy_x and joy_y variables, after calling initialise_joystick() you must 
   individually calibrate the top left and bottom right positions. Tell your 
   user to position the joystick in each corner, and then call the 
   appropriate calibration routine. See test.c for an example.

int save_joystick_data(char *filename);
   After calibrating the joystick, you may not want to make the user repeat 
   the process every time they run your program. Call this function to save 
   the joystick calibration data into the specified file, from which it can 
   later be restored by load_joystick_data().

int load_joystick_data(char *filename);
   Restores a set of calibration data previously saved by 
   save_joystick_data(). This sets up all aspects of the joystick module: 
   you don't even need to call initialise_joystick() before using it.



==========================================
============ Pallete routines ============
==========================================

Colors are stored in an RGB structure, which contains red, green and blue 
values each ranging from 0-63, and is defined as:

typedef struct RGB
{
   unsigned char r, g, b;
} RGB;

The type PALLETE is defined to be an array of 256 RGB structures.

void vsync();
   Waits for a vertical retrace to begin.

void set_color(int index, RGB *p);
   Sets the specified pallete entry to the specified RGB values. You should 
   call vsync() before doing this, to prevent snow problems.

void set_pallete(RGB *p);
   Sets the entire color pallete. You should provide an array of 256 RGB 
   structures. Unlike set_color(), there is no need to call vsync() before 
   this function.

void get_color(int index, RGB *p);
   Retrieves the specified pallete entry.

void get_pallete(RGB *p);
   Retrieves the entire color pallete. You should provide an array of 256 
   RGB structures to store it in.

void fade_in(RGB *p, int speed);
   Fades gradually from a black screen to the specified pallete. The speed 
   is from 1 (the slowest) up to 64 (instantaneous).

void fade_out(int speed);
   Fades gradually from the current pallete to a black screen. The speed is 
   from 1 (the slowest) up to 64 (instantaneous).

extern PALLETE black_pallete;
   A pallete containing solid black colors, used by the fade routines.

extern PALLETE desktop_pallete;
   The pallete used by the Atari ST low resolution desktop. I'm not quite 
   sure why this is still here, except that the grabber and test programs 
   use it. This is probably the only Atari legacy code left in Allegro, and 
   it would be a sin to remove it :-)



====================================================
============ Screen and bitmap routines ============
====================================================

int set_gfx_mode(int card, int w, int h, int v_w, int v_h);
   Selects a graphics mode. The card parameter should be one of the values 
   GFX_TEXT (to return to text mode), GFX_AUTODETECT (if you don't care what 
   driver Allegro uses), or one of the GFX_* constants from allegro.h. The w 
   and h parameters specify what screen resolution you want, and v_w and v_h 
   specify the minumum virtual screen size, in case you need a large virtual 
   screen for hardware scrolling (set them to zero if you don't care about 
   the virtual screen size). These are minimum values, and you are likely to 
   get a virtual screen much larger than the one you request. If Allegro is 
   unable to select an appropriate mode, set_gfx_mode() returns -1 and 
   stores a description of the problem in allegro_error. The possible modes 
   will vary according to your graphics card. 320x200 will always be 
   available, and the standard VESA modes (640x480, 800x600, and 1024x768) 
   are also likely to work.

   After you select a graphics mode, the physical and virtual screen sizes 
   can be checked with the macros SCREEN_W, SCREEN_H, VIRTUAL_W, and 
   VIRTUAL_H.

int scroll_screen(int x, int y);
   Attempts to scroll the hardware screen, returning 0 on success (it may 
   fail if the graphics driver can't handle hardware scrolling, or if the 
   virtual screen isn't large enough). You can use this to move the screen 
   display around in a large virtual screen space, or to implement double 
   buffering by flipping back and forth between two non-overlapping areas of 
   the virtual screen. Unfortunately, a lot of VESA implementations are very 
   buggy when it comes to scrolling, or can only handle horizontal scrolling 
   in four pixel increments, so it is probably not a good plan to rely too 
   heavily on this function.

All the Allegro graphics routines operate on BITMAP structures. A bitmap is 
an area of memory which is used to store an image, and which the graphics 
functions can draw onto. You can create and manipulate bitmaps in system 
RAM, or you can write directly to the special hardware 'screen' bitmap.

For example, to draw a pixel onto the screen you would do:

   putpixel(screen, x, y, color);

To implement a double-buffered system, you could write:

   BITMAP *b = create_bitmap(320, 200);
   putpixel(b, x, y, color);
   blit(b, screen, 0, 0, 0, 0, 320, 200);

Bitmaps are stored as packed byte arrays, with eight bits per pixel. See 
below for information on how to get direct access to the contents of these 
arrays.

extern BITMAP *screen;
   Global pointer to a bitmap, sized VIRTUAL_W x VIRTUAL_H. This is created 
   by set_gfx_mode(), and represents the hardware video memory. Only a 
   part of this bitmap will actually be visible, sized SCREEN_W x SCREEN_H. 
   Normally this is the top left corner of the larger virtual screen, so you 
   can ignore the extra invisible virtual size of the bitmap if you aren't 
   interested in hardware scrolling or page flipping. To move the visible 
   window to other parts of the screen bitmap, call scroll_screen(). 
   Initially the clipping rectangle will be limited to the physical screen 
   size, so if you want to draw onto a larger virtual screen space outside 
   this rectangle, you will need to adjust the clipping.

BITMAP *create_bitmap(int width, int height);
   Creates a memory bitmap sized width * height, and returns a pointer to 
   it. Clipping will be turned on, and the clipping rectangle set to the 
   full size of the bitmap. Memory bitmaps can be used to store graphics, or 
   as scratch space for double buffered systems.

void destroy_bitmap(BITMAP *bitmap);
   Destroys a memory bitmap when you are finished with it.

void set_clip(BITMAP *bitmap, int x1, int y1, int x2, int y2);
   Sets the two opposite corners of the clipping rectangle to be used when 
   drawing to this bitmap. Nothing will be drawn to positions outside of 
   this space. If x1, y1, x2 and y2 are all zero, clipping will be turned 
   off, which will slightly speed up drawing operations but will crash the 
   system if you try to draw beyond the edges of the bitmap.



===========================================
============ Graphics routines ============
===========================================

All these functions are affected by the clipping rectangle of the 
destination bitmap.

void xor_mode(int xor);
   Enables or disables exclusive-or drawing mode (defaults to off). In xor 
   mode, colors are written to the bitmap with an exclusive-or operation 
   rather than a simple copy, so drawing the same shape twice will erase it. 
   This only affects drawing routines like putpixel, lines, rectangles, 
   triangles, etc, not the blitting or sprite drawing functions. Because it 
   involves reading as well as writing to video memory, xor drawing is a lot 
   slower than the normal replace mode.

int getpixel(BITMAP *bmp, int x, int y);
   Reads a pixel from point x, y in the bitmap.

void putpixel(BITMAP *bmp, int x, int y, int color);
   Writes a pixel to the specified position in the bitmap.

void _putpixel(BITMAP *bmp, int x, int y, int color);
   Like the regular putpixel(), but much faster because it is implemented as 
   an inline assembler function. This version does not perform any clipping 
   (it will crash if you try to draw outside the bitmap!) and ignores the 
   xor drawing mode. It clobbers the %fs register, so you shouldn't mix it 
   with code that uses the _farsetsel() and _farns*() functions.

void vline(BITMAP *bmp, int x, int y1, int y2, int color);
   Draws a vertical line onto the bitmap, from x, y1 to x, y2.

void hline(BITMAP *bmp, int x1, int y, int x2, int color);
   Draws a horizontal line onto the bitmap, from x1, y to x2, y.

void do_line(BITMAP *bmp, int x1, y1, x2, y2, int d, void (*proc)());
   Calculates all the points along a line from x1, y1 to x2, y2, calling the 
   supplied function for each one. This will be passed a copy of the bmp 
   parameter, the x and y position, and a copy of the d parameter, so it is 
   suitable for use with putpixel()).

void line(BITMAP *bmp, int x1, int y1, int x2, int y2, int color);
   Draws a line onto the bitmap, from x1, y1 to x2, y2.

void triangle(BITMAP *bmp, int x1, y1, x2, y2, x3, y3, int color);
   Draws a filled triangle between the three points.

void polygon(BITMAP *bmp, int color, int vertices, ...);
   Draws a filled convex polygon with an arbitrary number of corners. Pass 
   the number of vertices, then a series of x, y points (a total of 
   vertices*2 values). Note that this routine can't draw concave shapes, 
   only convex ones (anyone want to donate a better polygon drawer?).

void rect(BITMAP *bmp, int x1, int y1, int x2, int y2, int color);
   Draws an outline rectangle.

void rectfill(BITMAP *bmp, int x1, int y1, int x2, int y2, int color);
   Draws a solid, filled rectangle.

void do_circle(BITMAP *bmp, int x, int y, int radius, int d, void (*proc)());
   Calculates all the points in a circle around point x, y with radius r, 
   calling the supplied function for each one. This will be passed a copy of 
   the bmp parameter, the x and y position, and a copy of the d parameter, 
   so it is suitable for use with putpixel()).

void circle(BITMAP *bmp, int x, int y, int radius, int color);
   Draws a circle with the specified centre and radius.

void circlefill(BITMAP *bmp, int x, int y, int radius, int color);
   Draws a filled circle with the specified centre and radius.

void draw_sprite(BITMAP *bmp, BITMAP *sprite, int x, int y);
   Draws the sprite bitmap onto the destination bitmap. A sprite draw is 
   almost the same as blit(sprite, bmp, 0, 0, x, y, sprite->w, sprite->h), 
   but it uses a masked drawing mode. Zero pixels in the sprite bitmap are 
   skipped, so the background image will show through the transparent parts 
   of the sprite. The sprite must be a memory bitmap, not 'screen'.

void draw_sprite_v_flip(BITMAP *bmp, BITMAP *sprite, int x, int y);
void draw_sprite_h_flip(BITMAP *bmp, BITMAP *sprite, int x, int y);
void draw_sprite_vh_flip(BITMAP *bmp, BITMAP *sprite, int x, int y);
   Like draw_sprite(), but these routines flip the sprite along the vertical,
   horizontal, or both, axis. These are mirror image flips, which are not 
   the same as rotating the sprite (and they are a lot faster than the 
   rotation routine).

void rotate_sprite(BITMAP *bmp, BITMAP *sprite, int x, int y, fixed angle);
   Draws the sprite image onto the bitmap at the specified position, 
   rotating it by the specified angle. The angle is a fixed point 16.16 
   number in the same format used by the fixed point trig routines, with 256 
   equal to a full circle, 64 a right angle, etc.

void blit(BITMAP *source, BITMAP *dest, int source_x, int source_y, 
	  int dest_x, int dest_y, int width, int height);
   Copies a rectangular area of the source bitmap to the destination bitmap. 
   The source_x and source_y parameters are the top left corner of the area 
   to copy from the source bitmap, and dest_x and dest_y are the position in 
   the destination bitmap. The width and height are the size of the area to 
   blit. This routine respects the clipping rectangle of the destination 
   bitmap, and it will also clip if you try to blit from areas outside the 
   source bitmap. It will work correctly even when the two memory areas 
   overlap (ie. source and dest are the same), but you should be wary of 
   blitting from one part of an SVGA screen bitmap to another because a lot 
   of SVGA cards don't provide seperate read and write banks, which makes it 
   very slow to copy from one part of video memory to another.

void stretch_blit(BITMAP *source, BITMAP *dest,
		  int source_x, source_y, source_width, source_height,
		  int dest_x, dest_y, dest_width, dest_height);
   Like blit(), except it can scale images so the source and destination 
   rectangles don't need to be the same size. This routine doesn't do as 
   much safety checking as the regular blit: in particular you must take 
   care not to copy from areas outside the source bitmap, and you cannot 
   blit between overlapping regions, ie. you must use different bitmaps for 
   the source and the destination. Also the source must be a memory bitmap, 
   not the hardware screen.

void clear_to_color(BITMAP *bitmap, int color);
   Clears the bitmap to the specified color.

void clear(bitmap);
   Clears the bitmap to color 0.

As well as the normal BITMAP structures, Allegro can store run length 
encoded sprites in an RLE_SPRITE structure. These are usually a lot smaller 
and often also faster than normal bitmaps, but you can't use them as a 
destination for drawing operations. You can create RLE sprites at runtime 
with the get_rle_sprite() function, and also by checking the RLE button in 
the grabber utility program.

RLE_SPRITE *get_rle_sprite(BITMAP *bitmap);
   Creates a run length encoded sprite based on the specified bitmap. The 
   returned sprite is likely to be a lot smaller than the original bitmap, 
   and can be drawn to the screen with draw_rle_sprite().

void destroy_rle_sprite(RLE_SPRITE *sprite);
   Destroys an RLE sprite structure returned by get_rle_sprite().

void draw_rle_sprite(BITMAP *bmp, RLE_SPRITE *sprite, int x, int y);
   Draws an RLE sprite onto a bitmap at the specified position.

Allegro provides text output routines that work with both proportional and 
fixed size 8x8 fonts. A font contains the ASCII characters 32-126. All other 
characters will be drawn as spaces.

extern FONT *font;
   A simple 8x8 font (the mode 13h default).

void text_mode(int mode);
   Sets the mode in which text will be drawn. If mode is positive, text 
   output will be opaque and the background will be set to mode. If mode is 
   negative, text will be drawn transparently (ie. the background will not 
   be altered). The default is a mode of zero.

void textout(BITMAP *bmp, FONT *f, char *str, int x, int y, int color);
   Writes the null terminated string str onto the bitmap at position x, y, 
   using the current text mode and the specified font and foreground color. 
   If color is -1 and a proportional font is in use, it will be drawn using 
   the colors from the original font bitmap (the one imported into the 
   grabber program), allowing multicolored text output.

void textout_centre(BITMAP *bmp, FONT *f, char *str, int x, int y, int color);
   Like textout(), but uses the x coordinate as the centre rather than the 
   left of the string.

int text_length(FONT *f, char *str);
   Calculates the length of a string in a particular font.

void destroy_font(FONT *f);
   Frees the memory being used by a font structure.



=============================================
============ Video memory access ============
=============================================

There are several ways to get direct access to the contents of an Allegro 
BITMAP structure. The simplest, if you know that it is a memory bitmap, is 
to use the array of unsigned char pointers which is a part of the bitmap 
structure to get a pointer to the start of the relevant line. For example, 
'putpixel(bmp, x, y, color)' is equivalent to 'bmp->line[y][x] = color'. 
This only works with memory bitmaps, however. You must not try to use it to 
write directly to the screen!

For more flexible access to bitmap memory, you need to call the bank 
switching functions:

unsigned long bmp_write_line(BITMAP *bmp, int line);
   Selects a line of a bitmap that you are going to draw onto.

unsigned long bmp_read_line(BITMAP *bmp, int line);
   Selects a line of a bitmap that you are going to read from.

These functions are not as inefficient as they might seem, because they are 
implemented as inline assembler routines, and when used with a memory 
bitmap they only perform a single table lookup.

Within each line, Allegro provides linear access to the bitmap memory, so 
you only need to pass the Y coordinate to these functions. Various X 
positions can be obtained by simply adding the X coordinate to the returned 
address.

The return value is an unsigned long rather than a char pointer, because the 
bitmap memory may not be in your data segment, and you need to access it 
with far pointers. This can be done with the functions in <sys/farptr.h> 
using the segment selector bmp->seg. For example, a putpixel which is 
capable of drawing onto any bitmap would be:

   #include <sys/farptr.h>

   void putpixel(BITMAP *b, int x, int y, int color)
   {
      unsigned long address = bmp_write_line(bmp, y);
      _farpokeb(bmp->seg, address+x, color);
   }

You will notice that Allegro provides seperate functions for setting the 
read and write banks. It is important that you use these, because on some 
graphics cards the banks can be set individually, and on others the video 
memory is read and written at different addresses. Unfortunately some cards 
only provide a single bank, and on these the read and write bank functions 
will behave identically. If you are only reading or only writing video 
memory that is no problem: you can just call the appropriate bank switcher 
and everything will work fine. If you are reading from one part of video 
memory and writing to another at the same time (eg. a blit from one part of 
the screen to another) this can get extremely awkward. The easiest solution 
is just not to blit from the screen onto itself...



========================================
============ Sound routines ============
========================================

int install_sound(int digi_card, int midi_card, char *cfg_path); 
   Initialises the sound module, returning zero on success. The two card 
   parameters should use the DIGI_* and MIDI_* constants defined in 
   allegro.h. Pass DIGI_AUTODETECT and MIDI_AUTODETECT if you don't know 
   what the soundcard is. For more detailed control over the sound hardware 
   you can edit the sound.cfg file (see readme.txt for details). Returns 
   zero on success, -1 on failure (and stores an error message in 
   allegro_error). The cfg_path is the name of the directory to load 
   sound.cfg from. Pass NULL to use the current directory, otherwise just 
   passing argv[0] will work.

void remove_sound();
   Cleans up after you are finished with the sound routines. You don't 
   normally need to call this, because allegro_exit() will do it for you.

SAMPLE *load_sample(char *filename);
   Loads a sample from a mono WAV file.

void destroy_sample(SAMPLE *spl);
   Destroys a sample structure when you are done with it. It is safe to call 
   this even when the sample might be playing, because it checks and will 
   kill it off if it is active.

void play_sample(SAMPLE *spl, int vol, int pan, int freq, int loop);
   Triggers a sample at the specified volume, pan position, and frequency. 
   The volume and pan range from 0 (min/left) to 255 (max/right). Frequency 
   is relative rather than absolute: 1000 represents the frequency that the 
   sample was recorded at, 2000 is twice this, etc. If the loop flag is set, 
   the sample will repeat until you call stop_sample(), and can be 
   manipulated while it is playing by calling adjust_sample().

void adjust_sample(SAMPLE *spl, int vol, int pan, int freq, int loop);
   Alters the parameters of a sample while it is playing (useful for 
   manipulating looped sounds). You can alter the volume, pan, and 
   frequency, and can also clear the loop flag, which will stop the sample 
   when it next reaches the end of its loop. If there are several copies of 
   the same sample playing, this will adjust the first one it comes across. 
   If the sample is not playing it has no effect.

void stop_sample(SAMPLE *spl);
   Kills off a sample, which is required if you have set a sample going in 
   looped mode. If there are several copies of the sample playing, it will 
   stop them all.

MIDI *load_midi(char *filename);
   Loads a standard MIDI file (handles both format 0 and format 1), 
   returning a pointer to a MIDI structure.

void destroy_midi(MIDI *midi);
   Destroys a MIDI structure when you are done with it. It is safe to call 
   this even when the MIDI file might be playing, because it checks and will 
   kill it off if it is active.

int play_midi(MIDI *midi, int loop);
   Starts playing the specified MIDI file, first stopping whatever music 
   was previously playing. If the loop flag is set, the data will be 
   repeated until replaced with something else, otherwise it will stop at 
   the end of the file. Passing a NULL pointer will stop whatever music is 
   currently playing. Returns non-zero if an error occurs (this may happen 
   if a patch-caching wavetable driver is unable to load the required 
   samples).

void stop_midi();
   Stops whatever music is currently playing. This is the same thing as 
   calling play_midi(NULL, FALSE).

extern volatile long midi_pos;
   Stores the current position (beat number) in the MIDI file. Useful for 
   synchronising animations with the music.



===========================================================
============ File I/O and compression routines ============
===========================================================

char *get_filename(char *path);
   When passed a completely specified file path, this returns a pointer to 
   the filename portion. Both '\' and '/' are recognized as directory 
   separators.

char *get_extension(char *filename);
   When passed a complete filename (with or without path information) this 
   returns a pointer to the file extension.

void put_backslash(char *filename);
   If the last character of the filename is not a '\' or '/', this routine 
   will concatenate a '\' on to it.

int file_exists(char *filename, int attrib, int *aret);
   Checks whether a file matching the given name and attributes exists, 
   returning non-zero if it does. The file attribute may contain any of the 
   FA_* constants from dir.h. If aret is not null, it will be set to the 
   attributes of the matching file. If an error occurs the system error code 
   will be stored in errno.

long file_size(char *filename);
   Returns the size of a file, in bytes. If the file does not exist or an 
   error occurs, it will return zero and store the system error code in 
   errno.

int delete_file(char *filename);
   Removes a file from the disk.

int for_each_file(char *name, int attrib, void (*callback)(), int param);
   Finds all the files on the disk which match the given wildcard 
   specification and file attributes, and executes callback() once for each. 
   callback() will be passed three arguments, the first a string which 
   contains the completed filename, the second being the attributes of the 
   file, and the third an int which is simply a copy of param (you can use 
   this for whatever you like). If an error occurs an error code will be 
   stored in errno, and callback() can cause for_each_file() to abort by 
   setting errno itself. Returns the number of successful calls made to 
   callback(). The file attribute may contain any of the FA_* flags from 
   dir.h.

The following routines implement a fast buffered file I/O system, which 
supports the reading and writing of compressed files using a ring buffer 
algorithm based on the LZSS compressor by Haruhiko Okumura. This does not 
achieve quite such good compression as programs like zip and lha, but 
unpacking is very fast and it does not require much memory. Packed files 
always begin with the 32 bit value F_PACK_MAGIC, and autodetect files with 
the value F_NOPACK_MAGIC.

PACKFILE *pack_fopen(char *filename, char *mode);
   Opens a file according to mode, which may contain any of the flags:
      'r' - open file for reading.
      'w' - open file for writing, overwriting any existing data.
      'p' - open file in 'packed' mode. Data will be compressed as it is 
	    written to the file, and automatically uncompressed during read 
	    operations. Files created in this mode will produce garbage if 
	    they are read without this flag being set. 
      '!' - open file for writing in normal, unpacked mode, but add the 
	    value F_NOPACK_MAGIC to the start of the file, so that it can be 
	    opened in packed mode and Allegro will automatically detect that 
	    the data does not need to be decompressed. 

   Instead of these flags, one of the constants F_READ, F_WRITE, 
   F_READ_PACKED, F_WRITE_PACKED or F_WRITE_NOPACK may be used as the mode 
   parameter. On success, pack_fopen() returns a pointer to a file 
   structure, and on error it returns NULL and stores an error code in 
   errno. An attempt to read a normal file in packed mode will cause errno 
   to be set to EDOM.

int pack_fclose(PACKFILE *f);
int feof(PACKFILE *f);
int ferror(PACKFILE *f);
int pack_getc(PACKFILE *f);
int pack_putc(int c, PACKFILE *f);
int pack_igetw(PACKFILE *f);
long pack_igetl(PACKFILE *f);
int pack_iputw(int w, PACKFILE *f);
long pack_iputl(long l, PACKFILE *f);
int pack_mgetw(PACKFILE *f);
long pack_mgetl(PACKFILE *f);
int pack_mputw(int w, PACKFILE *f);
long pack_mputl(long l, PACKFILE *f);
long pack_fread(void *p, long n, PACKFILE *f);
long pack_fwrite(void *p, long n, PACKFILE *f);
char *pack_fgets(char *p, int max, PACKFILE *f);
int pack_fputs(char *p, PACKFILE *f);

   These all work like the equivalent stdio functions, except that 
   pack_fread() and pack_fwrite() take a single size parameter instead of 
   that silly size and num_elements system. The pack_i* and pack_m* routines 
   read and write 16 and 32 bit values using the Intel and Motorola byte 
   ordering systems (endianness) respectively.



============================================
============ Data file routines ============
============================================

The grabber utility program creates data files, which can contain bitmaps, 
palletes, fonts, samples, MIDI music, and any other binary data that you 
import. To load one of these files into memory, call:

DATAFILE *load_datafile(char *filename);
   Loads a data file into memory, and returns a pointer to it. On error, 
   sets errno and returns NULL. All the objects in the file will be
   locked into physical memory.

void unload_datafile(DATAFILE *dat);
   Frees all the objects in a data file.

When you load a data file, you will obtain a pointer to an array of DATAFILE 
structures:

typedef struct DATAFILE
{
   void *dat;     - pointer to the actual data
   int type;      - data type
   long size;     - if type == DAT_DATA, this is the size of the data
} DATAFILE;

The type field will be one of the values:
   DAT_DATA       - dat points to a block of binary data
   DAT_FONT_8x8   - dat points to an 8x8 fixed pitch font
   DAT_FONT_PROP  - dat points to a proportional font
   DAT_BITMAP     - dat points to a BITMAP structure
   DAT_PALLETE    - dat points to an array of 256 RGB structures
   DAT_SAMPLE     - dat points to a sample structure
   DAT_MIDI       - dat points to a MIDI file
   DAT_RLE_SPRITE - dat points to a RLE_SPRITE structure
   DAT_END        - special flag for the end of the data list

The grabber program will also produce a header file defining the index of 
each object within the file. So, for example, if you have made a data file 
which contains a bitmap called THE_IMAGE, you could display it with the code 
fragment:

   DATAFILE *data = load_datafile("foo.dat");
   draw_sprite(screen, data[THE_IMAGE].dat, x, y);

BITMAP *load_pcx(char *filename, RGB *pal);
   Loads a 256 color PCX file, returning a pointer to a bitmap and storing 
   the pallete data in the specified location (this should be an array of at 
   least 256 RGB structures). You are responsible for destroying the bitmap 
   when you are finished with it.

int save_pcx(char *filename, BITMAP *bmp, RGB *pal);
   Writes a bitmap into a PCX file, using the specified pallete (this should 
   be an array of at least 256 RGB structures).



===========================================================
============ Fixed point (16.16) math routines ============
===========================================================

Allegro provides some routines for working with fixed point numbers, and 
defines the type 'fixed' to be a signed 32 bit integer. The high word is 
used for the integer part and the low word for the fraction, giving a range 
of -32768 to 32767 and an accuracy of about four or five decimal places. 
Fixed point numbers can be assigned, compared, added, subtracted, negated 
and shifted (for multiplying or dividing by powers of two) using the normal 
integer operators, but you should take care to use the appropriate 
conversion routines when mixing fixed point with integer or floating point 
values. Writing 'fixed_point_1 + fixed_point_2' is ok, but 'fixed_point + 
integer' is not.

To convert fixed point values to and from integer and floating point 
formats, use the macros:

fixed itofix(int x);    - converts an integer to fixed point
int fixtoi(fixed x);    - converts fixed point to integer
fixed ftofix(float x);  - converts a floating point value to fixed point
float fixtof(fixed x);  - converts fixed point to floating point

A fixed point value can be multiplied or divided by an integer with the 
normal '*' and '/' operators. To multiply or divide two fixed point values, 
however, you must use the functions:

fixed fmul(fixed x, fixed y);
fixed fdiv(fixed x, fixed y);

If an overflow or division by zero occurs, errno will be set and the maximum 
possible value will be returned, but errno is not cleared if the operation 
is successful. This means that if you are going to test for overflow you 
should set errno=0 before calling fmul() or fdiv().

The square root, sin, cos, and tan functions are implemented using lookup 
tables, which are very fast although not particularly accurate. Angles are 
represented in a binary format with 256 equal to a full circle, 64 being a 
right angle and so on. This has the advantage that a simple bitwise 'and' 
can be used to keep the angle within the range zero <-> a full circle. The
inverse trig routines use iterative algorithms, so they are quite slow.

fixed fsin(fixed x);             - sin table lookup
fixed fcos(fixed x);             - cosine table lookup
fixed ftan(fixed x);             - tangent table lookup
fixed fasin(fixed x);            - search table for inverse sin
fixed facos(fixed x);            - search table for inverse cosine
fixed fatan(fixed x);            - search table for inverse tangent
fixed fatan2(fixed y, fixed x);  - like the floating point atan2()
fixed fsqrt(fixed x);            - fixed point square root routine

If you are programming in C++ you can use the fix class, which overloads a 
lot of operators to provide automatic conversion to and from integer and 
floating point values, and calls the above routines as they are required. 
You should not mix the fix class with the fixed typedef though, because the 
compiler will mistake the fixed values for regular integers and insert 
unneccessary conversions. For example, if x is an object of class fix, 
calling fsqrt(x) will return the wrong result. You should use the overloaded 
sqrt(x) or x.sqrt() instead.



=======================================
============ GUI routines  ============
=======================================

Allegro contains a simple object-oriented dialog manager which lets you 
easily define new GUI object types by writing your own dialog procedures.

A dialog is stored as an array of DIALOG structures:

typedef struct DIALOG
{
   int (*proc)(int, DIALOG *, int);    - dialog procedure (message handler)
   int x, y, w, h;                     - position and size of the object
   int fg, bg;                         - foreground and background colors
   int key;                            - ASCII code of keyboard shortcut
   int flags;                          - flags about the status of the object
   int d1, d2;                         - whatever you want to use them for
   void *dp;                           - pointer to more object-specific data
} DIALOG;

The last element in the array should have the proc pointer set to NULL.

The flags field may contain any of the flags:
   D_EXIT          - this object should close the dialog when it is clicked
   D_SELECTED      - this object is selected
   D_GOTFOCUS      - this object has got the input focus
   D_GOTMOUSE      - the mouse is currently on top of this object
   D_HIDDEN        - this object is hidden and inactive

The dialog procedure should be declared as:
   int foo(int msg, DIALOG *d, int c);

This will be called by the dialog manager whenever any action concerning the 
object is required, or can be called directly with the SEND_MESSAGE macro. 
It will be passed a flag (msg) indicating what action it should perform, a 
pointer to the object concerned (d), and if msg == MSG_CHAR, the key that 
was pressed (c). Note that d is a pointer to a specific object, and not to 
the entire dialog.

The dialog procedure should return one of the values:
   D_O_K          - normal return status
   D_CLOSE        - tells the dialog manager to close the dialog
   D_REDRAW       - tells the dialog manager to redraw the entire dialog
   D_WANTFOCUS    - requests that the input focus be given to this object
   D_USED_CHAR    - for MSG_CHAR messages, to override default actions

Dialog procedures may recieve any of the messages:

MSG_START:
   Tells the object to initialise itself. The dialog manager sends this to 
   all the objects in a dialog just before it displays the dialog.

MSG_END:
   Sent to all objects when closing a dialog, allowing them to perform 
   whatever cleanup operations they require.

MSG_DRAW:
   Tells the object to draw itself onto the screen bitmap. The mouse pointer 
   will be turned off when this message is sent, so the drawing code does 
   not need to worry about it.

MSG_CLICK:
   Informs the object that a mouse button has been clicked while the mouse 
   was on top of the object. Typically an object will perform its own mouse 
   tracking as long as the button is held down, and only return from this 
   message handler when it is released.

MSG_DCLICK:
   Sent when the user double-clicks on an object. A MSG_CLICK will be sent 
   when the button is first pressed, then MSG_DCLICK if it is released and 
   pressed again within a short space of time.

MSG_KEY:
   Sent when the keyboard shortcut for the object is pressed, or if <enter> 
   is pressed while it has the input focus.

MSG_CHAR:
   When a key is pressed, this message is sent to the object that has the 
   input focus. If the object deals with the keypress it should return 
   D_USED_CHAR, otherwise it should return D_O_K to allow the default 
   keyboard interface to operate.

MSG_WANTFOCUS:
   Queries whether an object is willing to accept the input focus. It should 
   return D_WANTFOCUS if it does, or D_O_K if it isn't interested in getting 
   user input.

MSG_GOTFOCUS:
MSG_LOSTFOCUS:
   Sent whenever an object gains or loses the input focus. These messages 
   will always be followed by a MSG_DRAW, allowing objects to display 
   themselves differently when they have the input focus.

MSG_GOTMOUSE:
MSG_LOSTMOUSE:
   Sent when the mouse moves on top of or away from an object. If the object 
   is displayed differently when the mouse is on top of it, it is 
   responsible for redrawing itself in response to these messages.

MSG_IDLE:
   Sent whenever the dialog manager has nothing better to do.

Allegro provides several standard dialog procedures. You can use these as 
they are to provide simple user interface objects, or you can call them from 
within your own dialog procedures, giving a kind of oop class inheritance. 
For instance, you could make an object which calls d_button_proc to draw 
itself, but handles the click message in a different way.

int d_clear_proc(int msg, DIALOG *d, int c);
   This just clears the screen when it is drawn. Useful as the first object 
   in a dialog.

int d_box_proc(int msg, DIALOG *d, int c);
int d_shadow_box_proc(int msg, DIALOG *d, int c);
   These just draw a boxes on the screen, with or without a shadow.

int d_bitmap_proc(int msg, DIALOG *d, int c);
   This draws a bitmap onto the screen, which should be pointed to by the 
   dp field.

int d_text_proc(int msg, DIALOG *d, int c);
int d_ctext_proc(int msg, DIALOG *d, int c);
   These draw text onto the screen. The dp field should point to the string 
   to display. d_ctext_proc() centres the string around the x coordinate.

int d_button_proc(int msg, DIALOG *d, int c);
   A button object (the dp field points to the text string). This object can 
   be selected by clicking on it with the mouse or by pressing its keyboard 
   shortcut. If the D_EXIT flag is set, selecting it will close the dialog, 
   otherwise it will toggle on and off.

int d_check_proc(int msg, DIALOG *d, int c);
   This is an example of how you can derive objects from other objects. Most 
   of the functionality comes from d_button_proc(), but it displays itself 
   as a check box.

int d_edit_proc(int msg, DIALOG *d, int c);
   An editable text object (the dp field points to the string). When it has 
   the input focus (obtained by clicking on it with the mouse), text can be 
   typed into this object. The d1 field specifies the maximum number of 
   characters that it will accept, and d2 is the text cursor position within 
   the string.

int d_list_proc(int msg, DIALOG *d, int c);
   A list box object. This will allow the user to scroll through a list of 
   items and to select one by clicking or with the arrow keys. If the D_EXIT 
   flag is set, double clicking on a list item will close the dialog. The 
   index of the selected item is held in the d1 field, and d2 is used to 
   store how far it has scrolled through the list. The dp field points to a 
   function which will be called to obtain information about the contents of 
   the list. This should follow the form:
      char *foo(int index, int *list_size);
   If index is zero or positive, the function should return a pointer to the 
   string which is to be displayed at position index in the list. If index 
   is negative, it should return NULL and list_size should be set to the 
   number of items in the list. 

The behaviour of the dialog manager can be controlled by the variables:

extern int gui_mouse_focus;
   If set, the input focus follows the mouse pointer around the dialog.

extern int gui_fg_color, gui_bg_color;
   The foreground and background colors for the standard dialogs (alerts and 
   the file selector). They default to 255 and 0.

void centre_dialog(DIALOG *dialog);
   Moves an array of dialog objects so that it is centered in the screen.

void set_dialog_color(DIALOG *dialog, int fg, int bg);
   Sets the foreground and background colors of an array of dialog objects.

int dialog_message(DIALOG *dialog, int msg, int c, int *obj);
   Sends a message to all the objects in an array. If any of the dialog 
   procedures return values other than D_O_K, it returns the value and sets 
   obj to the index of the object which produced it.

int do_dialog(DIALOG *dialog, int focus_obj);
   The basic dialog manager. This displays a dialog (an array of dialog 
   objects, terminated by one with a NULL dialog procedure), and sets the 
   input focus to the focus_obj (this should be -1 to have no initial 
   focus). It interprets user input and despatches messages as they are 
   required, until one of the dialog procedures tells it to close the 
   dialog, at which point it returns the index of the object that caused it 
   to exit.

int popup_dialog(DIALOG *dialog, int focus_obj);
   Like do_dialog(), but it stores the data on the screen before drawing the 
   dialog and restores it when the dialog is closed. The screen area to be 
   stored is calculated from the dimensions of the first object in the 
   dialog, so all the other objects should lie within this one.

int alert(char *s1, char *s2, char *s3, char *b1, char *b2, int c1, int c2);
   Displays a popup alert box, containing three lines of text (s1-s3), and 
   with either one or two buttons. The text for these buttons is passed in 
   b1 and b2 (b2 may be null), and the keyboard shortcuts in c1 and c2. 
   Returns 1 or 2 depending on which button was clicked.

int file_select(char *message, char *path, char *ext);
   Displays the Allegro file selector, with the message as caption. Allows 
   the user to select a file, and stores the selection in path (which should 
   have room for at least 80 characters). The files are filtered according 
   to the file extensions in ext. Passing NULL includes all files, "PCX;BMP" 
   includes only files with .PCX or .BMP extensions. Returns zero if it was 
   closed with the Cancel button, non-zero if it was OK'd.

int gfx_mode_select(int *card, int *w, int *h);
   Displays the Allegro graphics mode selection dialog, which allows the 
   user to select a screen mode and graphics card. Stores the selection in 
   the three variables, and returns zero if it was closed with the Cancel 
   button or non-zero if it was OK'd.



=======================================
============ In Conclusion ============
=======================================

<insert witty anecdote here>

There. Every time you look at that you can think of a different funny story. 
If you don't think mine is any good, you can insert one of your own. 
Complete flexibility, uniquely tailored to your individual needs.

Enjoy. If you find any of this stuff useful, write and tell me about it.
I want to hear from you!


By Shawn Hargreaves,
1 Salisbury Road,
Market Drayton,
Shropshire,
England, TF9 1AJ.

Email slh100@tower.york.ac.uk. This will only exist until summer 1996! If 
you want to contact me after this summer, go download the latest version of 
Allegro, and my new address will be in there.
